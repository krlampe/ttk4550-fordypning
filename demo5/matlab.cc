#include <stdio.h>
#include <string>
#include "strategy.hh"
#include "ast.hh"
#include "dox.hh"

/**
 * Modify the AST of an equation so that the names of nodes are matlab compatible.
 * Variable names are converted to y(i), where i is the variable's index in the
 * matlab matrix y, which is equal to its index in the symbol table plus 1.
 * (Matlab has 1-based indexing.)
 * 
 * Pruning: If a parameter is set to 0 in dox, all of its multiplications are optimized.
 * All subtrees mulitplyed by a 0 are deleted and replaced by an AstNumber{0}.
*/
class MatlabPreprocessor : public AstVisitor {
public:
  void visit(AstNumber *node);
  void visit(AstSymbol *node);
  void visit(AstVariable *node);
  void visit(BinaryOperator *node);
  void visit(UnaryOperator *node);
  void visit(BuiltInFunc *node);

private:
  bool prune = false;
};

/**
 * Print RHS of differential equations for matlab code by visiting ASTs.
 */
class MatlabPrinter : public AstVisitor {
public:
  MatlabPrinter(FILE *outputfile) : out{outputfile} {}

  void visit(AstNumber *node);
  void visit(AstSymbol *node);
  void visit(AstVariable *node);
  void visit(BinaryOperator *node);
  void visit(UnaryOperator *node);
  void visit(BuiltInFunc *node);

private:
  FILE *out;
};

void CodeGenerator::generate_matlab(FILE *out) {
  SymbolTable *symbol_table = SymbolTable::get_instance();

  /* Heading */
  fputs("%% Simulator generated by sim-gen.\n% ODE:\n", out);
  for (const auto& sym : symbol_table->get_symbols()) {
    fprintf(out, "%% (d/dt)%s = ", sym.name.c_str());
    sym.equation->print(out);
    fputs("\n", out);
  }

  /* Modify all the ASTs */
  for (const auto& sym : symbol_table->get_symbols()) {
    MatlabPreprocessor modify_visitor{};
    sym.equation->accept(&modify_visitor);
  }

  /*
  Print matlab formated equations:
      dydt = @(t, y) [<equations>];
  */
  fputs("\ndydt = @(t, y) [", out);
  for (const auto& sym : symbol_table->get_symbols()) {
    MatlabPrinter print_visitor{out};
    sym.equation->accept(&print_visitor);
    fputs(";", out);
  }
  fputs("];\n", out);

  /* Initial values */
  fputs("y_0 = [ ", out);
  for (double y0 : dox.initial_values) {
    fprintf(out, "%g ", y0);
  }
  fputs("];\n", out);

  /* Time interval */
  fprintf(out, "tspan = [ %g %g ];\n", dox.interval.start, dox.interval.end);

  /* Possible options */
  if (dox.time_step) {
    fprintf(out, "options = odeset('InitialStep', %g);\n", dox.time_step);
  }

  /* Integrator */
  if (!dox.time_step) {
    fprintf(out, "[t,y] = %s(dydt, tspan, y_0);\n", dox.solver.c_str());
  } else {
    fprintf(out, "[t,y] = %s(dydt, tspan, y_0, options);\n", dox.solver.c_str());
  }

  /* Plotting */
  fputs(
    "figure; clf;\n"
    "hold on;\n",
    out
  );
  for (int i = 0; i < symbol_table->get_nr_of_equations(); i++) {
    fprintf(out, "plot(t,y(:,%d),'%s');\n", i+1, dox.plot_style.c_str());
  }
  fputs(
    "hold off;\n"
    "grid on;\n"
    "xlabel('Time t');\n"
    "ylabel('Solution');\n",
    out
  );
  fprintf(out, "legend('%s'", symbol_table->get_symbols()[0].name.c_str());
  for (int i = 1; i < symbol_table->get_nr_of_equations(); i++) {
    fprintf(out, ", '%s'", symbol_table->get_symbols()[i].name.c_str());
  }
  fputs(");\n", out);
}


/* MatlabPreprocessor */

void MatlabPreprocessor::visit(AstNumber *node) {}

void MatlabPreprocessor::visit(AstSymbol *node) {
  const Symbol& sym = SymbolTable::get_instance()->get_symbol(node->name);
  node->name = "y(" + std::to_string(sym.index+1) + ")";
}

void MatlabPreprocessor::visit(AstVariable *node) {
  if (SymbolTable::get_instance()->lookup_param(node->name)) {
    if (SymbolTable::get_instance()->get_param_value(node->name) == 0) {
      prune = true;
    }
  }
}

void MatlabPreprocessor::visit(BinaryOperator *node) {
  if (node->operat == '*') {
    // if prune is set, pass it on upwards
    node->left->accept(this);
    if (prune) {
      return;
    }
    node->right->accept(this);
    if (prune) {
      return;
    }
  } else if (node->operat == '/' || node->operat == '^') {
    // if prune is set by the numerator, pass it on upwards
    node->left->accept(this);
    if (prune) {
      return;
    }
    // if prune is set by the denumerator, handle it,
    // although it could give a divide by zero (user error)
    node->right->accept(this);
    if (prune) {
      delete node->right;
      node->right = new AstNumber{0};
      prune = false;
    }
  } else { // all other operators always handle the pruning
    node->left->accept(this);
    if (prune) {
      delete node->left;
      node->left = new AstNumber{0};
      prune = false;
    }

    node->right->accept(this);
    if (prune) {
      delete node->right;
      node->right = new AstNumber{0};
      prune = false;
    }
  }
}

void MatlabPreprocessor::visit(UnaryOperator *node) {
  // All unary operators (both 'M' and 'abs') pass potenial pruning upwards
  node->operand->accept(this);
}

void MatlabPreprocessor::visit(BuiltInFunc *node) {
  node->argument->accept(this);
  if (prune) {
    delete node->argument;
    node->argument = new AstNumber{0};
    prune = false;
  }
}


/* MatlabPrinter */

void MatlabPrinter::visit(AstNumber *node) {
	fprintf(out, "%g", node->value);
}

void MatlabPrinter::visit(AstSymbol *node) {
	fprintf(out, "%s", node->name.c_str());
}

void MatlabPrinter::visit(AstVariable *node) {
  if (SymbolTable::get_instance()->lookup_param(node->name)) {
    fprintf(out, "%g", SymbolTable::get_instance()->get_param_value(node->name));
  } else {
	  fprintf(out, "%s", node->name.c_str());
  }
}

void MatlabPrinter::visit(BinaryOperator *node) {
  fprintf(out, "%c",'(');
  node->left->accept(this);
  fprintf(out, "%c", node->operat);
  node->right->accept(this);
  fprintf(out, "%c",')');
}

void MatlabPrinter::visit(UnaryOperator *node) {
	if (node->operat == 'M') {
		fputs("(-", out);
		node->operand->accept(this);
    fputs(")", out);
	}	else if (node->operat == 'A') {
		fputs("abs(", out);
		node->operand->accept(this);
		fputs(")", out);
	}
}

void MatlabPrinter::visit(BuiltInFunc *node) {
  // assumes that the input uses the same names as matlab for built-ins
  fprintf(out, "%s", node->name.c_str());
	fprintf(out, "%s","(");
	node->argument->accept(this);
	fprintf(out, "%s",")");
}
